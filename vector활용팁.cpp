/*
* vector를 사용하는데 알아두면 좋은 점을 몇가지 소개합니다.
* vector는 원소를 삽입할때 자동으로 확장될 수 있는 동적 배열 클래스입니다.
* 컴파일 시점에 크기가 결정되어 있지 않으므로 벡터가 지역변수든 전역변수든 내부적으로 힙메모리를 할당받아 데이터를 저장합니다.
* 그리고 vector는 배열과 같이 메모리 공간 내에서 각 원소가 연속하도록하여 관리하는 컨테이너입니다.
* 그래서 vector에는 size라는 개념과 capacity라는 개념이 따로 존재합니다.
* size는 실제로 vector 안에 있는 원소의 개수를 의미합니다.
* capacity는 메모리 공간 내에서 이사(?)하지 않고 확장 가능한 최대 크기입니다.
* 만약 특정 베이스 주소에서 capacity가 12인데 vector에 push를 하면서 그보다 큰 사이즈를 가져야하는 상황이 온다면
* vector는 OS에게 다시 필요한 크기만큼의 동적 메모리를 쿼리합니다.
* 그 후 새로운 원래 메모리에 있던 모든 원소를 새로운 메모리로 복제하고 사이즈를 키웁니다.
* 따라서 이러한 이사(realloc)이 자주 발생하면 오버헤드가 상당히 크다고 할 수 있습니다.
* 그런데 vector의 기본 생성자는 size와 capacity가 0인 상태로 생성해줍니다.
* 그리고 capacity는 1->2->4->8->16... 과 같이 2의 제곱꼴로 커집니다.
* 즉 vector의 크기가 작을 수록 이러한 이사가 빈번하게 발생합니다.
* 필요한 크기를 미리 알고있다면 생성과 동시에 할당하거나,
* 최초에 한번 미리 realloc하는 등의 방법으로 이러한 오버헤드를 제거할 수 있습니다.
*
* vector는 인덱스가 커지는 방향으로만 확장이 가능합니다.
* 만약 vector의 맨 앞에 원소를 삽입하게 된다면 나머지 원소들을 전부 한칸씩 밀어야 하므로 오버헤드가 큽니다.
* string도 vector를 기반으로 한 클래스이므로 마찬가지입니다.
* 만약 맨 앞과 맨 뒤에서 삽입/삭제가 발생한다면 vector 대신 deque(덱) 클래스를 사용하는 것이 좋습니다.
* 
*/

#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>
using namespace std;

int main() {
	/*
	* 다음은 vector를 생성하는 다양한 방법을 보여줍니다.
	*/

	//1. 생성할 때 할당을 동시에 하기
	// 생성 시점에서 할당되므로 이후에는 push_back이나 emplace_back을 사용하지 않고 배열과 같이 인덱스로 접근
	vector<int> v1(1000);
	for (int i = 0; i < v1.size(); ++i)
		v1[i] = i;

	//2. resize로 한번에 확장하기
	//resize는 현재 size보다 크게 할 수도 작게 할 수도 있습니다.
	//작게 하는 경우 realloc은 발생할 일이 없으므로 기존에 있던 데이터는 그대로 남아있게 됩니다.
	vector<int> v2;
	v2.resize(1000);
	for (int i = 0; i < v1.size(); ++i)
		v1[i] = i;

	//3. 원소 없이 생성한 후 reserve로 capacity 확장하기
	// 이 방법은 capacity를 지정함으로써 명시적 시점에 realloc이 발생하게 합니다.
	// 원소가 없는 상태에서 수행하면 복사오버헤드가 발생하지 않습니다.
	vector<int> v3;
	v3.reserve(1000);
	for (int i = 0; i < v1.size(); ++i)
		v1.push_back(i);

	//4. vector의 생성자에는 첫번째 파라미터로 크기를, 두번째 파라미터로 각 원소를 초기화할 값을 받는 버전이 있습니다.
	vector<int> v4(1000, 999);

	//5. vector의 생성자에는 호모지니어스(모두 같은 타입)한 원소들을 나열하는 initialize_list를 파라미터로 받는 버전이 있습니다.
	vector<int> v5({ 1,2,3,4,5,6,7,8,9 });

	//6. 중첩된 vector 초기화 예
	//다음은 100 x 100 이차원 배열을 123으로 초기화하며 생성합니다.
	vector<vector<int>> v6(100, vector<int>(100, 123));

	/*
	* 다음은 vector와 관련한 유용한 정보입니다.
	*/

	//7. vector<bool>
	//bool 벡터는 대리자 패턴으로 특수화되어 있어 실제 데이터는 비트 단위로 컨트롤 하면서 사용자에게는 bool타입의 대리자를 노출합니다.
	//따라서 일반 배열 등과 비교하여 메모리를 대략 1/8만큼만 차지하게 됩니다.
	vector<bool> v7;

	//8. emplace_back
	//원소를 push할때 임시 객체를 생성하여 넣는다면 push_back 대신 emplace_back을 쓰는게 좋습니다.
	//push_back으로 임시객체를 넘기게 되면 한번의 이동 생성이 발생하지만 emplace_back을 쓰면 함수 내에서 바로 객체를 생성하기 때문에
	//이동 비용을 아낄 수 있습니다.
	vector<pair<int, int>> v8;
	//v8.push_back({ 1,2 }); 안좋은 예
	v8.emplace_back(1, 2);

	//9. vector를 파라미터로 받는다면 const& vector
	//참조형 파라미터로 받으면 참조정보만 전달됩니다. 보통 메모리 주소 하나가 복제되는 만큼의 오버헤드를 갖습니다.
	//const참조형은 왼값 뿐만 아니라 오른값에도 바인딩 될 수 있습니다.
	auto func = [](const vector<int>& v)
	{
		//...
	};
	func({ 1,2,3 });

	//10. 반복적인 참조 정보의 복사 오버헤드 조차 아깝다면 객체를 이동하는 방법도 있습니다.
	//이동은 복사와 달리 얕은 복사를 수행합니다. 이동 후 원본 객체는 더이상 유효하지 않습니다.
	vector<int> a;
	vector<int> b;
	a = move(b); // 여기서 b는 오른값으로 전달되어 a의 이동 대입 연산자가 호출됨

	//11. 맨 앞에서 삽입/삭제가 일어난다면 deque 사용
	deque<int> dq {2,3,4};
	dq.push_front(1);

	//12. 벡터에서 중복 요소 제거
	//벡터에서 중복을 제거하기 위해선 우선 정렬되어 있어야 합니다.
	//unique함수는 주어진 범위가 정렬되었다고 가정하고 작동하기 때문입니다.
	//unique함수는 중복 요소들을 swap하여 뒤쪽으로 보내고, 중복 요소들이 시작하는 위치의 반복자를 반환합니다.
	//unique가 이런식으로 구현되어 있는 이유는 vector, deque과 같이 중간에서의 삭제가 비효율적인 컨테이너들이 있기 때문입니다.
	//unique가 반환한 반복자를 erase메서드에 전달해주면 실제로 원소가 제거됩니다.
	vector<int> v12 {6,2,3,4,3,1,1,6};
	sort(v12.begin(), v12.end());
	v12.erase(unique(v12.begin(), v12.end()));
}